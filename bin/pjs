#!/usr/bin/env node

var fs      = require('fs');
var program = require('commander');
var split   = require('split');
var async   = require('async');
var pjs     = require('../lib/pjs');

var summ = "  Functions and expressions are invoked in the following order:\n" +
           "  filter, map, reduce\n\n" +
           "  Built-in reduce functions: length, min, max, sum, avg, concat\n" +
           "  Custom reduce expressions accept: prev, curr, i, array";

program
  .version(require('../package.json').version)
  .usage("[options] [files ...]\n\n" + summ)
  .option('-e, --explicit', 'bind lines to $')
  .option('-j, --json', 'output as json')
  .option('-f, --filter <exp>', 'filter by a boolean expression')
  .option('-m, --map <exp>', 'map values using the expression')
  .option('-r, --reduce <func|exp>',
    'reduce using a function or expression')
  .parse(process.argv);

process.on('uncaughtException', function(e) {
  // Handle errors in expression syntax
  if (e instanceof SyntaxError || e instanceof ReferenceError) {
    console.error('Invalid expression :', e.message);
    process.exit(3);
  }

  console.error(e.stack);
  process.exit(1);
});

// Print help if no actions were provided
if (!program.filter && !program.map &&
    !program.reduce && !program.json) {
  program.help();
}

// Assume all unconsumed arguments are paths
var paths = program.args || [];

// Pipe input and process
var dstStream = getDestination();
if (paths.length) {
  pipeFiles(paths, dstStream);
} else {
  process.stdin.pipe(dstStream);
}

/**
 * Returns the destination stream to be used by a readable stream. The
 * destination stream is a split stream that pipes to the various actions,
 * and finally, stdout.
 *
 * @return {Stream} The destination stream
 */
function getDestination() {
  var prev, splitStream, stream;
  prev = splitStream = split();

  // Have to output a string if writing to stdout
  var outputString = {
    filter: !(program.map || program.reduce || program.json),
    map:    !(program.reduce || program.json),
    reduce: !program.json
  };

  // Pipe to each action, when set
  ['filter', 'map', 'reduce'].forEach(function(action) {
    if (program[action]) {
      stream = pjs[action](program[action], outputString[action],
        program.explicit);

      prev.pipe(stream, {end: false});
      prev = stream;
    }
  });

  // Add the json stream, if enabled
  if (program.json) {
    stream = pjs.json(!program.reduce);
    prev.pipe(stream);
    prev = stream;
  }

  prev.pipe(process.stdout);

  return splitStream;
}

/**
 * Iterates over the given paths, reading the files and piping their data to
 * the passed destination stream.
 *
 * @param {string[]} path      The file paths
 * @param {Stream}   dstStream The destination stream
 */
function pipeFiles(paths, dstStream) {
  // Keep the destination open between files
  var opts = {end: false};

  async.eachSeries(paths, function(path, next) {
    fs.createReadStream(path)
      .on('end', next)
      .pipe(dstStream, opts);
  }, function () {
    dstStream.end();
  });
}
